import random


def sort(seq):
    """
    Назовём <единицей> тот случай, когда следующий день теплее предыдущего
    Первый случай:
        Если среди двух соседних дней <единицы_1> нет другой <единицы>,
        то от <единицы_0> до <единицы_1> стоит монотонно убывающая последовательность
        Более того, n = n - 1
        Пример:
            Дано: 0, 1, 0, -3, -4, -3, -4, -5, -6, -7, -8
                Ставим единицы: _, _, 1, _, _, _, 1, _, _, _, _, _, _
                <единица_0> - индекс [0]
                <единица_1> - индекс [4]
            Выход: 1, 4, 3, 2, 1, _, _, _, _, _, _
    Второй случай:
        Если среди двух и более соседних и дней <единицы_1> имеются другие <единицы>,
        то для каждого числа в диапазоне от <единицы_0> до <единицы_1> более теплый день
        находится в диапазоне от всех рядом стоящих соседей <единицы_1> до максимального элемента,
        являющимся концом списка.
        Если список содержит другие максимальные элементы, отбрасываем их и стоящие перед ними числа
        Пример:
            Дано: 9, 7, 4, 4, 4, 8, 5, 5, 5, 6, 0, 0, 0, 1, 0, -5, -4, -3, 0, 0, -1, -1, -2, -8, -7, -1, 4
                Последний элемент - 4, он обязан являться максимальным элементом,
                таким образом отбрасываем 6 и все числа до неё:
                Промежуточный этап:
                0, 0, 0, 1, 0, -5, -4, -3, 0, 0, -1, -1, -2, -8, -7, -1, 4
                Ставим <единицы> и промежутки:
                3, 2, 1, [2,13], [1,12], 1, 1, 1, [5,8], [4,7], [3,6], [2,5], [1,4], 1, 1, 1, MAX
                Сравниваем второй набор <единиц> с элементами, стоящими 'до' при этом каждый раз сокращая промежутки
                Сравниваем последний набор <единиц> и сокращаем промежутки:
                3, 2, 1, [2,13], [1,12], 1, 1, 1, [7,8], [6,7], [5,6], [4,5], 3, 1, 1, 1, MAX
                Ещё раз:
                3, 2, 1, [2,13], [1,12], 1, 1, 1, 8, 7, 6, 5, 3, 1, 1, 1, MAX
                И с оставшимися единицами:
                3, 2, 1, 13, 12, 1, 1, 1, 8, 7, 6, 5, 3, 1, 1, 1, MAX
            Выход: 3, 2, 1, 13, 12, 1, 1, 1, 8, 7, 6, 5, 3, 1, 1, 1, MAX

    Алгоритм пробегает по длине разбиения, начиная с [1]-го элемента
    Самое первое и очевидное, что делает алгоритм - ставит <единицу> как минимально возможную длину
    Далее, самое простое, что может алгоритм - проставить числа, следующие за единицей в порядке возрастания,
    пока не наткнётся на очередную <единицу>
    (при условии, что последовательность убывает и ∃ только одна <единица>, от которой начинается отсчёт!)
    На данном моменте оценка сложности, очевидно, O(n)
    Далее алгоритм приступает ко 'второму' случаю, сравнивая каждый элемент с каждой последовательностью n > 1 <единиц>
    """
    if not seq:  # У пустого списка нет результата, возвращаем обратно
        return []
    days_in_row, ones_in_row = 1, 0  # Количество чередующихся дней с единицами и количество чередующихся единиц
    max_i = 0  # Счётчик, делающий отбор по чередующимся единицам
    out = []  # Его мы будем выводить
    ii = 1  # Обычный счётчик, аналогично i
    max_index_list = [0]  # Список, хранящий индексы чередующихся единиц
    for _ in range(len(seq) - 1):
        if seq[ii - 1] > seq[ii]:
            out.append(1)
            max_index_list.append(ii)
            max_i = 0
            ii += 1
            ones_in_row += 1
        elif ones_in_row == 1:
            days_in_row += 1
            out.append(days_in_row)
            ii += 1
        else:
            while not seq[max_index_list[-max_i - 1]] <= seq[ii] < seq[max_index_list[-max_i - 2]]:
                max_i += 1
            else:
                out.append(ii - max_index_list[-max_i - 2])
                ii += 1
            days_in_row, ones_in_row = 1, 0
    return out


def rand_list(n):
    lst = []
    for _ in range(n):
        lst.append(random.randint(-30, 30))
    print('START')
    return lst


'''november \
    = [9, 7, 4, 4, 4, 8, 5, 5, 5, 6, 0, 0, 0, 1, 0, -5, -4, -3, 0, 0, -1, -1, -2, -8, -7, -1, 4, 1, -1, 1, 1]'''
#november = rand_list(1000000)
november = [-18, 21, -1, 5, 28, -14, -29, 27, -10, 4, -10, -30, -25, 4, -1, 4, 27, 23, -30, 11, 8, -2, -27, 25, 11, -22, -18, -26, -2, 29]
print('Начальный список:')
print(*november, sep=', ')
output = [None]  # Список, который формируем на выход
max_temp = november[-1]  # Минимально максимальная температура, очевидно, последняя в календаре
november.reverse()
temp_list = []  # Временный список для разбиения от одного максимума до другого

for i in range(1, len(november)):  # Проход справа налево с выделением максимумов
    if november[i] >= max_temp:  # Выделяем максимум -> разбиение помещаем в функцию -> очищаем temp_list
        max_temp = november[i]
        output += sort(temp_list)
        temp_list.clear()
        temp_list.append(november[i])
        output.append(None)  # Так как был максимум температуры, фиксируем его как None
    else:
        temp_list.append(november[i])  # Пополняем временный temp_list (делаем разбиение)

output.reverse()
print('Результат:')
print(*output, sep=', ')
